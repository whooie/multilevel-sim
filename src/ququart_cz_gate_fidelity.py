from itertools import product
import re
import sys
import numpy as np
import sympy as sy
import whooie.pyplotdefs as pd
FS = pd.pp.rcParams["figure.figsize"]
pd.pp.rcParams["figure.figsize"] = [FS[0], FS[1] * 0.65]
pd.set_font("/usr/share/fonts/OTF/MyriadPro-Regular.otf", "MyriadPro")

try:
    mode = int(sys.argv[1])
except:
    print("missing integer mode argument")
    sys.exit(1)

if mode == 0:
    ph_ex = sy.symbols(" ".join(f"phi{bin(k)[2:]:>04}" for k in range(16)), real=True)
    ph0, ph1 = sy.symbols("phi0 phi1", real=True)

    atom_states = ["G0", "G1", "C0", "C1"]
    CZ = sy.diag([
        sy.S(1) if "".join(ss).count("C") == 0
        else sy.exp(sy.I * ph0) if "".join(ss).count("C") == 1
        else sy.exp(sy.I * (2 * ph0 - sy.pi))
        for ss in product(atom_states, atom_states)
    ], unpack=True)
    G = sy.Matrix([
        [+1.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +1.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, -0.724302+0.689474*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, -0.725502+0.688217*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +1.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +1.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, -0.724302+0.689474*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, -0.725502+0.688217*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, -0.724302+0.689474*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, -0.724302+0.689474*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.889477-0.427735*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, -0.051244+0.998672*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, -0.725502+0.688217*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, -0.725502+0.688217*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, -0.051244+0.998672*sy.I, +0.000000+0.000000*sy.I],
        [+0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.000000+0.000000*sy.I, +0.888869-0.428366*sy.I],
    ]).T

    def clean_expr_str(expr: sy.Expr) -> str:
        s = str(expr.simplify())
        s = re.sub("I", "1j", s)
        s = re.sub(r"(sin|cos|exp|sqrt)", r"np.\1", s)
        return s

    expr = abs(sy.trace(CZ.H * G)) / 16
    dexpr = expr.diff(ph0)
    d2expr = dexpr.diff(ph0)
    print(clean_expr_str(expr))
    print(clean_expr_str(dexpr))
    print(clean_expr_str(d2expr))
elif mode == 1:
    def F(phi0: float) -> float:
        return abs(
            0.573198133623031*np.sqrt(((-0.0796980522321862*np.exp(2*1j*phi0) + 0.0542735984931998*1j*np.exp(2*1j*phi0) - 0.235016493959819*np.exp(1j*phi0) - 0.450558383476741*1j*np.exp(1j*phi0) + 1 - 1.31995987437407e-17*1j)*np.exp(2*1j*phi0) + (-0.235016493959819 + 0.450558383476741*1j)*np.exp(1j*phi0) - 0.0796980522321862 - 0.0542735984931998*1j)*np.exp(-2*1j*phi0))
        )

    def dF(phi0: float) -> float:
        return abs(
            ((-0.0311095253613079*np.exp(1j*phi0) - 0.0456827747928799*1j*np.exp(1j*phi0) + 0.129129612248539 - 0.0673555078541982*1j)*np.exp(3*1j*phi0) + (0.129129612248539 + 0.0673555078541982*1j)*np.exp(1j*phi0) - 0.0311095253613079 + 0.0456827747928799*1j)*np.exp(-2*1j*phi0)/np.sqrt(((-0.0796980522321862*np.exp(2*1j*phi0) + 0.0542735984931998*1j*np.exp(2*1j*phi0) - 0.235016493959819*np.exp(1j*phi0) - 0.450558383476741*1j*np.exp(1j*phi0) + 1 - 1.31995987437407e-17*1j)*np.exp(2*1j*phi0) + (-0.235016493959819 + 0.450558383476741*1j)*np.exp(1j*phi0) - 0.0796980522321862 - 0.0542735984931998*1j)*np.exp(-2*1j*phi0))
        )

    def d2F(phi0: float) -> float:
        return abs(
            np.sqrt(((-0.0796980522321862*np.exp(2*1j*phi0) + 0.0542735984931998*1j*np.exp(2*1j*phi0) - 0.235016493959819*np.exp(1j*phi0) - 0.450558383476741*1j*np.exp(1j*phi0) + 1 - 1.31995987437407e-17*1j)*np.exp(2*1j*phi0) + (-0.235016493959819 + 0.450558383476741*1j)*np.exp(1j*phi0) - 0.0796980522321862 - 0.0542735984931998*1j)*np.exp(-2*1j*phi0))*(((0.0913655495857598*np.exp(1j*phi0) - 0.0622190507226157*1j*np.exp(1j*phi0) + 0.0673555078541982 + 0.129129612248539*1j)*np.exp(3*1j*phi0) + (0.0673555078541982 - 0.129129612248539*1j)*np.exp(1j*phi0) + 0.0913655495857598 + 0.0622190507226157*1j)*((-0.0796980522321862*np.exp(2*1j*phi0) + 0.0542735984931998*1j*np.exp(2*1j*phi0) - 0.235016493959819*np.exp(1j*phi0) - 0.450558383476741*1j*np.exp(1j*phi0) + 1 - 1.31995987437407e-17*1j)*np.exp(2*1j*phi0) + (-0.235016493959819 + 0.450558383476741*1j)*np.exp(1j*phi0) - 0.0796980522321862 - 0.0542735984931998*1j) - 0.02909021467684*((0.240917050857634*np.exp(1j*phi0) + 0.353774583516546*1j*np.exp(1j*phi0) - 1 + 0.52161163253985*1j)*np.exp(3*1j*phi0) - (1 + 0.52161163253985*1j)*np.exp(1j*phi0) + 0.240917050857634 - 0.353774583516546*1j)**2)/((-0.0796980522321862*np.exp(2*1j*phi0) + 0.0542735984931998*1j*np.exp(2*1j*phi0) - 0.235016493959819*np.exp(1j*phi0) - 0.450558383476741*1j*np.exp(1j*phi0) + 1 - 1.31995987437407e-17*1j)*np.exp(2*1j*phi0) + (-0.235016493959819 + 0.450558383476741*1j)*np.exp(1j*phi0) - 0.0796980522321862 - 0.0542735984931998*1j)**2
        )


    def newton_raphson(
        phi0_init: float,
        maxiters: int,
        epsilon: float,
    ) -> float:
        phi0 = phi0_init
        for _ in range(maxiters):
            dphi0 = -dF(phi0) / d2F(phi0)
            if abs(dphi0) < epsilon:
                return phi0
            phi0 += dphi0
            phi0 = phi0 % (2 * np.pi)
        print("reached maxiters")
        return phi0

    INVPHI = 0.6180339887498949 # inverse golden ratio
    INVPHI2 = 0.3819660112501051 # inverse golden ratio squared

    def gen_golden_point(bracket: (float, float), r: float) -> float:
        h = abs(bracket[1] - bracket[0])
        x0 = min(bracket)
        return x0 + r * h

    def golden_section(
        phi0_init: (float, float),
        maxiters: int,
        epsilon: float,
    ) -> float:
        x0, x3 = phi0_init
        x1 = gen_golden_point((x0, x3), INVPHI2)
        x2 = gen_golden_point((x0, x3), INVPHI)
        f1 = F(x1)
        f2 = F(x2)
        for _ in range(maxiters):
            if f1 > f2:
                if abs(x3 - x0) < epsilon:
                    return x1
                x3 = x2
                x2 = x1
                f2 = f1
                x1 = gen_golden_point((x0, x3), INVPHI2)
                f1 = F(x1)
            else:
                if abs(x3 - x0) < epsilon:
                    return x2
                x0 = x1
                x1 = x2
                f1 = f2
                x2 = gen_golden_point((x0, x3), INVPHI)
                f2 = F(x2)
        print("reached maxiters")
        if f1 > f2:
            return x1
        else:
            return x2

    # ph = np.linspace(0.0, 2.0 * np.pi, 1000)
    # (
    #     pd.Plotter()
    #     .plot(ph, F(ph))
    #     .plot(ph, dF(ph))
    #     .plot(ph, d2F(ph))
    #     .show()
    # )

    # phi0_init = +2.3
    # sol = newton_raphson(phi0_init, maxiters=1000, epsilon=1e-6)
    phi0_init = (0.0, np.pi)
    sol = golden_section(phi0_init, maxiters=1000, epsilon=1e-9)
    print(
f"""
phi0 = {sol:.6f}
F = {F(sol):.6f}
dF = {dF(sol):.6f}
d2F = {d2F(sol):.6f}
"""[1:-1]
    )
elif mode == 2:
    # # r_sep = 2.4 μm
    # data = np.array([ # ζ, F
    #     [0.000, 0.999996],
    #     [0.011, 0.999996],
    #     [0.050, 0.999996],
    #     [0.100, 0.999993],
    #     [0.150, 0.999990],
    #     [0.200, 0.999995],
    #     [0.250, 0.999993],
    #     [0.300, 0.999962],
    #     [0.350, 0.999993],
    #     [0.400, 0.999994],
    #     [0.450, 0.999084],
    #     [0.500, 0.999993],
    #     [0.550, 0.999995],
    #     [0.600, 0.999996],
    #     [0.650, 0.999994],
    #     [0.700, 0.999996],
    #     [0.750, 0.999996],
    #     [0.800, 0.999993],
    #     [0.850, 0.999970],
    #     [0.900, 0.999995],
    #     [0.950, 0.999994],
    #     [1.000, 0.249999],
    # ])
    # (
    #     pd.Plotter()
    #     .semilogy(data[:, 0], 1 - data[:, 1])
    #     .ggrid()
    #     .set_xlabel("$\\zeta$")
    #     .set_ylabel("$1 - \\mathcal{F}$")
    #     .savefig("output/ququart_cz_gate_fidelity_zeta.png")
    #     .close()
    # )

    # # r_sep = 6.25 μm
    # data = np.array([ # η, F
    #     [0.000010000, 0.749991],
    #     [0.000017783, 0.749992],
    #     [0.000031623, 0.749993],
    #     [0.000056234, 0.749995],
    #     [0.000100000, 0.750001],
    #     [0.000177828, 0.750020],
    #     [0.000316228, 0.750076],
    #     [0.000562341, 0.750246],
    #     [0.001000000, 0.750770],
    #     [0.001778279, 0.752360],
    #     [0.003162278, 0.757004],
    #     [0.005623413, 0.769377],
    #     [0.010000000, 0.797113],
    #     [0.017782794, 0.844887],
    #     [0.031622777, 0.902787],
    #     [0.056234133, 0.949490],
    #     [0.100000000, 0.980934],
    #     [0.177827941, 0.993877],
    #     [0.316227766, 0.998512],
    #     [0.562341325, 0.999776],
    #     [1.000000000, 0.999981],
    # ])

    # (
    #     pd.Plotter()
    #     .loglog(data[:, 0], 1 - data[:, 1])
    #     .ggrid()
    #     .set_xlabel("$\\eta$")
    #     .set_ylabel("$1 - \\mathcal{F}$")
    #     .savefig("output/ququart_cz_gate_fidelity_eta.png")
    #     .close()
    # )

    data_special = np.array([ # η, F
        # r_sep = 2.4 μm
        [0.000010000, 0.756438],
        [0.000017783, 0.767990],
        [0.000031623, 0.794152],
        [0.000056234, 0.839752],
        [0.000100000, 0.896055],
        [0.000177828, 0.942963],
        [0.000316228, 0.976167],
        [0.000562341, 0.990914],
        [0.001000000, 0.996877],
        [0.001778279, 0.998968],
        [0.003162278, 0.999667],
        [0.005623413, 0.999893],
        [0.010000000, 0.999964],
        [0.017782794, 0.999986],
        [0.031622777, 0.999993],
        [0.056234133, 0.999994],
        [0.100000000, 0.999995],
        [0.177827941, 0.999989],
        [0.316227766, 0.999996],
        [0.562341325, 0.999978],
        [1.000000000, 0.999996],
    ])

    data_scan = np.array([
        # r_sep = 2.35033095 μm
        [ # η, F
            [0.000010000, 0.757989],
            [0.000017783, 0.771801],
            [0.000031623, 0.801680],
            [0.000056234, 0.850567],
            [0.000100000, 0.906738],
            [0.000177828, 0.949605],
            [0.000316228, 0.979451],
            [0.000562341, 0.992549],
            [0.001000000, 0.997425],
            [0.001778279, 0.999137],
            [0.003162278, 0.999711],
            [0.005623413, 0.999900],
            [0.010000000, 0.999962],
            [0.017782794, 0.999982],
            [0.031622777, 0.999989],
            [0.056234133, 0.999991],
            [0.100000000, 0.999992],
            [0.177827941, 0.999987],
            [0.316227766, 0.999966],
            [0.562341325, 0.999994],
            [1.000000000, 0.999994],
        ],
        # r_sep = 3.06821169 μm
        [ # η, F
            [0.000010000, 0.750344],
            [0.000017783, 0.751099],
            [0.000031623, 0.753402],
            [0.000056234, 0.760005],
            [0.000100000, 0.776728],
            [0.000177828, 0.811054],
            [0.000316228, 0.863226],
            [0.000562341, 0.918510],
            [0.001000000, 0.958057],
            [0.001778279, 0.983937],
            [0.003162278, 0.994284],
            [0.005623413, 0.998073],
            [0.010000000, 0.999385],
            [0.017782794, 0.999809],
            [0.031622777, 0.999942],
            [0.056234133, 0.999982],
            [0.100000000, 0.999993],
            [0.177827941, 0.999995],
            [0.316227766, 0.999996],
            [0.562341325, 0.999993],
            [1.000000000, 0.999997],
        ],
        # r_sep = 4.00536061 μm
        [ # η, F
            [0.000010000, 0.750018],
            [0.000017783, 0.750054],
            [0.000031623, 0.750163],
            [0.000056234, 0.751500],
            [0.000100000, 0.751500],
            [0.000177828, 0.754488],
            [0.000316228, 0.762798],
            [0.000562341, 0.782924],
            [0.001000000, 0.821764],
            [0.001778279, 0.876284],
            [0.003162278, 0.929308],
            [0.005623413, 0.966946],
            [0.010000000, 0.987095],
            [0.017782794, 0.995498],
            [0.031622777, 0.998535],
            [0.056234133, 0.999540],
            [0.100000000, 0.999860],
            [0.177827941, 0.999957],
            [0.316227766, 0.999984],
            [0.562341325, 0.999990],
            [1.000000000, 0.999991],
        ],
        # r_sep = 5.22875057 μm
        [ # η, F
            [0.000010000, 0.749998],
            [0.000017783, 0.750000],
            [0.000031623, 0.750004],
            [0.000056234, 0.750018],
            [0.000100000, 0.750060],
            [0.000177828, 0.750194],
            [0.000316228, 0.750611],
            [0.000562341, 0.751892],
            [0.001000000, 0.755689],
            [0.001778279, 0.766043],
            [0.003162278, 0.790124],
            [0.005623413, 0.833784],
            [0.010000000, 0.890263],
            [0.017782794, 0.940025],
            [0.031622777, 0.975087],
            [0.056234133, 0.990878],
            [0.100000000, 0.997038],
            [0.177827941, 0.999168],
            [0.316227766, 0.999806],
            [0.562341325, 0.999968],
            [1.000000000, 0.999994],
        ],
        # r_sep = 6.82581050 μm
        [ # η, F
            [0.000010000, 0.749980],
            [0.000017783, 0.749980],
            [0.000031623, 0.749980],
            [0.000056234, 0.749980],
            [0.000100000, 0.749982],
            [0.000177828, 0.749988],
            [0.000316228, 0.750007],
            [0.000562341, 0.750065],
            [0.001000000, 0.750248],
            [0.001778279, 0.750817],
            [0.003162278, 0.752556],
            [0.005623413, 0.757638],
            [0.010000000, 0.771096],
            [0.017782794, 0.800853],
            [0.031622777, 0.851050],
            [0.056234133, 0.910069],
            [0.100000000, 0.955464],
            [0.177827941, 0.984677],
            [0.316227766, 0.995927],
            [0.562341325, 0.999375],
            [1.000000000, 0.999958],
        ],
    ])

    N = data_scan.shape[0]
    P = pd.Plotter()
    for k in range(data_scan.shape[0]):
        opacity = 1 -  0.75 * k / (N - 1)
        P.loglog(
            data_scan[k, :, 0], 1 - data_scan[k, :, 1],
            marker="o", linestyle="-", color="C4", alpha=opacity,
            zorder=N - k,
        )
    (
        P
        # .loglog(
        #     data_special[:, 0], 1 - data_special[:, 1],
        #     marker="o", linestyle="-", color="r",
        #     zorder=N - 1,
        # )
        .ggrid().grid(False, which="both")
        .set_xlabel("η")
        .set_ylabel("1 – $\\mathcal{F}$")
        .savefig("output/ququart_cz_gate_fidelity_eta_scan.png")
        .savefig("output/ququart_cz_gate_fidelity_eta_scan.pdf")
        .close()
    )

